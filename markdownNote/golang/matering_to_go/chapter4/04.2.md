# 结构体

虽然array, slice，map这类数据结构的确很不错，但是呢，它们不能将多个值聚合到同一个地方。当你需要将不同类型的不同变量聚合到一个地方来创建一个新的类型的时候，你就可以使用结构体。结构体中的元素叫**结构体的字段**或者就是字段。

我会以讲解一个简单的结构体为例来开始这一节，这个结构体就是上一章在`sortSlie.go`中定义的:
```go
type aStructure struct {
	person string
	height int
	weight int
}
```

结构体的字段通常是大写字母开头，这很大程度上取决于如何使用这个字段。当你学习过第六章*What You Might Not Know About Go Packages and Go*后，这个问题的原因就会非常显而易见。这个结构体有三个字段，分别是`person`，`height`,`weight`。现在，你可以创建一个类型为`aStructure`的变量了:

```go
var s1 aStructure
```

另外，你可以通过字段的名字来访问这个字段。所以，为了获取变量`s1`的`person`字段的值，你可以输入`s1.person`。

一个**结构体字面量**可以这样定义：

```go
p1 := aStructure{"fmt",12,-2}
```

当然记住结构体中字段的声明顺序可能确实比较困难，Go语言还允许你用另外一种方式来定义结构体字面量:

```go
 p1 := aStructure{weight: 12, height:-2}
```

用这种方式定义的时候，你不必为结构体中的每个字段都提供初始值。

现在你已经了解了结构体的基本操作，让我们尝试一些实战性更强的代码吧，这部分代码保存在`structures.go`中，分为四部分。

第一部分代码：

 ```go
package main

import (
	"fmt"
)

 ```

>  通常来说，Go结构体和Go基本类型都是是定义在`main()`函数外面的，这样在整个Go package中可以拥有全局的属性，除非你想声明这个结构提类型值在当前空间内有效，不想它在别的地方被使用。
>

第二部分代码：

 ```go
func main(){
	type XYZ struct {
		X int
		Y int
		Z int
	}

	var s1 XYZ
	fmt.Println(s1.Y, s1.Z)

 ```

从这里我们就可以看到确实可以在函数内部定义结构体，但是这样做的时候一定要有充分的理由

我们使用两种定义结构体字面量的方式定义了`p1`与`p2`,并且打印出来。

第三部分：

 ```go
	p1 := XYZ{23,12, -2}
	p2 := XYZ{Z:12,Y:13}
	fmt.Println(p1)
	fmt.Println(p2) 
 ```

这里你定义了两个结构体字面量，分别命名p1和p2，然后打印这两个变量

最后一部分代码：

```go
	pSlice := [4]XYZ{}
	pSlice[2] = p1
	pSlice[0] = p2
	fmt.Println(pSlice)
	p2 = XYZ{1,2,3}
	fmt.Println(pSlice)
}
```

最后一部分代码中，我们创建了一个结构体数组`pSlice`，当你将一个结构体分配给结构体数组，那么这个结构体就会被深拷贝至这个数组，这意味着改变原结构体是对数组中的结构体没有影响的，从下面的打印输出中我们能够看出来：

```shell
$ go run structures.go
0 0
{23 12 -2}
{0 13 12}
[{0 13 12} {0 0 0} {23 12 -2} {0 0 0}]
[{0 13 12} {0 0 0} {23 12 -2} {0 0 0}]
```

> 注意，结构体中字段的定义顺序是有意义的，简单来说，就算两个结构体拥有相同的字段，但是字段的声明顺序不同，那么这两个结构体也是不相同的。
>

从程序输出中我们能够知道，结构体中的变量是初始化为其类型的零值。
