# 字符串

严格来说，Go字符串并不是组合类型，但是Go提供了很多支持字符串的函数，所以我决定在这章中详细讨论下strings。

*第3章*提到过Go字符串是值类型，并非像C字符串需要靠指针实现。另外，Go默认支持UTF-8字符串，所以你不必导入其他包就可以打印Unicode字符。下面的小节也会讲到字符、rune、字节之间的区别，以及字符串与字符串字面量的不同。

Go字符串实际上是一个字节切片，可以存储任意类型、任意长度的字节。

可以像下面一样定义一个字符串字面量：

```go
const sLiteral = "\x99\x42\x32\x55\x50\x35\x23\x50\x29\x9c" 
```

你可能觉得字符串字面量的样子奇怪。你还可以这样定义一个string变量：

```go
s2 := "€£3"
```

可以使用`len()`得到字符串的长度。

`strings.go`将会分五部分展示一些Go字符串的标准操作。第一部分：

```go
package main

import (
	"fmt"
)
```
第二部分：
```go
func main() {
	const sLiteral= "\x99\x42\x32\x55\x50\x35\x23\x50\x29\x9c"
	fmt.Println(sLiteral)
	fmt.Printf("x: %x\n", sLiteral)

	fmt.Printf("sLiteral length: %d\n", len(sLiteral))
```

每一个`\xAB`都代表`sLiteral`的一个字符，所以调用`len()`就会得到`sLiteral`的字符数量。`%x`会得到`\xAB`中的`AB`部分。

第三部分代码：

```go
	for i := 0; i < len(sLiteral); i++ {
		fmt.Printf("%x ", sLiteral[i])
	}
	fmt.Println()

	fmt.Printf("q: %q\n", sLiteral)
	fmt.Printf("+q: %+q\n", sLiteral)
	fmt.Printf(" x: % x\n", sLiteral)

	fmt.Printf("s: As a string: %s\n", sLiteral)
```

如代码所示，你可以像操作一个切片那样去操作字符串。使用`%q`作为字符串格式化参数，可以安全地打印出带双引号的字符串，`%+q`可以保证输出是ASCII格式。

最后，`% x`（注意%与x之间的空格）将会在输出的字符之间加上空格，如果你想打印字符串格式，就要使用`%s`。

第四部分代码：

```go
	s2 := "€£³"
	for x, y := range s2 {
		fmt.Printf("%#U starts at byte position %d\n", y, x)
	}

	fmt.Printf("s2 length: %d\n", len(s2))
```

在这里定义了字符串`s2`，内容是3个unicode字符。使用`%#U`可以打印出`U+0058`格式的字符，`range`关键字能够迭代包含Unicode字符的字符串，这样就可以逐个处理Unicode字符。

`len(s2)`的输出可能会令你困惑，解释一下，`s2`包含的是Unicode字符，Unicode字符的字节数量是大于该字符串中的元素数量的，而`len()`函数计算的是字节数量，所以`len(s2)`的值是7而不是3。

最后一部分：

```go
	const s3= "ab12AB"
	fmt.Println("s3:", s3)
	fmt.Printf("x: % x\n", s3)

	fmt.Printf("s3 length: %d\n", len(s3))

	for i := 0; i < len(s3); i++ {
		fmt.Printf("%x ", s3[i])
	}
	fmt.Println()
}
```

执行`strings.go`的输出是：

```shell
$ go run strings.go
�B2UP5#P)�
x: 9942325550352350299c
sLiteral length: 10
99 42 32 55 50 35 23 50 29 9c
q: "\x99B2UP5#P)\x9c"
+q: "\x99B2UP5#P)\x9c"
x: 99 42 32 55 50 35 23 50 29 9c
s: As a string: �B2UP5#P)�
U+20AC '€' starts at byte position 0
U+00A3 '£' starts at byte position 3 
U+00B3 '3' starts at byte position 5 
s2 length: 7
s3: ab12AB
x: 61 62 31 32 41 42
s3 length: 6
61 62 31 32 41 42
```

在不清楚Unicode和UTF-8机制的情况下，你可能会对本节的输出干到困惑，不必恐慌，因为这些在平时的开发中很少使用，基本的`fmt.Printf()`和`fmt.Println()`就能满足你的需求。但是，如果你不是在欧洲和美国，你可能会发现这些信息是非常有用的。

