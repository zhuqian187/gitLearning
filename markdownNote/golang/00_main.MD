## Go基础

### Golang内置类型与函数

#### 内置函数

```plain
    append          -- 用来追加元素到数组、slice中,返回修改后的数组、slice
    close           -- 主要用来关闭channel
    delete            -- 从map中删除key对应的value
    panic            -- 停止常规的goroutine  （panic和recover：用来做错误处理）
    recover         -- 允许程序定义goroutine的panic动作
    real            -- 返回complex的实部   （complex、real imag：用于创建和操作复数）
    imag            -- 返回complex的虚部
    make            -- 用来分配内存，返回Type本身(只能应用于slice, map, channel)
    new                -- 用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针
    cap                -- capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）
    copy            -- 用于复制和连接slice，返回复制的数目
    len                -- 来求长度，比如string、array、slice、map、channel ，返回长度
    print、println     -- 底层打印函数，在部署环境中建议使用 fmt 包
```

#### 内置接口error

```golang
    type error interface { //只要实现了Error()函数，返回值为String的都实现了err接口

            Error()    String

    }
```

### 运算符

#### 逻辑运算符

| 运算符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| `&&`   | 逻辑AND运算符。如果两边操作数都是True，则为True，否则为False |
| `\|\|` | 逻辑OR运算符。如果两边操作数有一个为True，则为True，否则为False |
| `!`    | 逻辑NOT运算符，如果条件为True，则为False，否则为True         |

#### 位运算符

| 运算符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| `&`    | 参与运算的两数各对应的二进位相与。（两位均为1才为1）         |
| `\|`   | 参与运算的两数各对应的二进位相或。（两位有一个为1就为1）     |
| `^`    | 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。（两位不一样则为1） |
| `<<`   | 左移n位就是乘以2的n次方。“a<<b”是把a的各二进位全部左移b位，高位丢弃，低位补0。 |
| `>>`   | 右移n位就是除以2的n次方。“a>>b”是把a的各二进位全部右移b位。  |

### 变量与常量

#### 变量声明

变量需要声明后才能使用，在同一个作用域中，不支持变量的重复声明。实际上是不支持没有新声明的变量作用在声明缓环节。

```
var 变量名 变量类型
```

#### 变量的初始化

```
var 变量名 类型 = 表达式 // 标准格式
变量名1, ... := 表达式1, ... // 多个变量的一次声明，短声明格式；注意，短声明格式不能用在函数之外
var name = "pprof.cn" // 类型推到，编译器更具等号右边的值来推导变量的类型初始化
_, _ := 表达式1， 表达式2 // 下划线意味可以丢弃的变量或者包
```

### 基本类型

#### Go基本类型系统

| 类型      | 长度（字节） | 默认值 | 说明                                 |
| --------- | ------------ | ------ | ------------------------------------ |
| bool      | 1            | false  |                                      |
| byte      | 1            | 0      | uint8                                |
| rune      | 4            | 0      | Unicode Code Point， int32           |
| int, uint | 4或者8       | 0      | 32位或者64位（取决于操作系统，GOOS） |
| uintptr   | 4或者8       |        | 以存储指针的uint32或者uint64整数     |
| arrary    |              |        | 值类型                               |
| struct    |              |        | 值类型                               |
| string    |              | ""     | UTF-8字符串                          |
| slice     |              | nil    | 引用类型                             |
| map       |              | nil    | 引用类型                             |
| channel   |              | nil    | 引用类型                             |
| interface |              | nil    | 接口                                 |
| function  |              | nil    | 函数                                 |

#### 字符串

字符串的转义符

| 转义 | 含义                               |
| ---- | ---------------------------------- |
| `\r` | 回车符（返回行首）                 |
| `\n` | 换行符（直接跳到下一行的同列位置） |
| `\t` | 制表符                             |
| `\'` | 单引号                             |
| `\"` | 双引号                             |
| `\`  | 反斜杠                             |

多行字符串使用 `反引号` 字符

```Go
    s1 := `第一行
    第二行
    第三行
    `
    fmt.Println(s1)
```

字符串的常用操作，

| 方法            | 介绍         |
| --------------- | ------------ |
| len(str)        | 求长度       |
| package strings | String基本库 |

#### 切片slice

slice的声明

```golang
全局声明与定义
var arr = [...]int{0, 1, 2, 3, 4} // 定义一个数组，arrary
var slice0 []int = arr[start:end] OR arr[start:] OR arr[:end] OR arr[:]

局部作用域声明与定义：
arr2 = [...]int{5, 6, 7, 8, 9}
slice1 = arr[start:end] OR arr[start:] OR arr[:end] OR arr[:]

通过make来创建切片
全局:
var slice []type = make([]type, len)
局部:
slice := make([]type, len) // cap = len
slice := make([]type, len, cap) // cap >= len
```

> 一个奇怪的slice  
> [][]T, 指元素类型为 []T 的 slice。可以为 slice, struct, map, channel 或者其他一些奇奇怪怪的对象

slice操作含义

| 操作            | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| s[n]            | 切片s中索引位置为n的项                                       |
| s[:]            | 从切片s的索引 0 到 len(s)-1 处所获得的切片                   |
| s[low:]         | 从切片s的索引 low 到 len(s)-1 处所获得的切片                 |
| s[:high]        | 从切片s的索引 0 到 high 处所获得的切片, len = high           |
| s[low:high]     | 从切片s的索引 low 到 high 处所获得的切片, len = high - low   |
| s[low:high:max] | 从切片s的索引 low 到 high 处所获得的切片, len = high - low , cap = max - low |
| len(s)          | 切片s的长度，总是 <= cap(s)                                  |
| cap(s)          | 切片s的容量，总是 >= len(s)                                  |

slice的一些函数操作

| 关键字 | 一些说明                                                     |
| ------ | ------------------------------------------------------------ |
| append | 追加写入，向 slice 尾部添加数据，返回新的 slice 对象         |
| copy   | 函数 copy 在两个 slice 间复制数据，复制长度以 len 小的为准，两个 slice 可指向同一底层数组，允许元素区间重叠。 |
| range  | 通过 range 遍历 slice。 index, value := range slice          |
| \-     | 调整 slice 的大小， 参考slice操作含义                        |

#### slice 的底层实现

切片常见的操作有 reslice, append, copy。同时，切片还具有索引， 可迭代的优秀特性。

Go数组是值类型，每次传递参数，都会将数据拷贝一遍。所以，数组建议使用指针方式传递，避免拷贝。但是通过指针传递有一个弊端，因为指针指向的值是绝对路径，一改全改。需要根据需求实际考虑。

slice 的数据结构定义

```golang
type slice struct {
    array unsafe.Poniter
    len int
    cap int
}
```

nil 和空切片

> var slice []T  
> slice := make([]T, 0)  
> slice := []int{}

切片的扩容策略

> 如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。  
> 一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每次增加原来容量的四分之一。

### 指针

指针的三大概念

- 指针地址
- 指针类型
- 指针取值

取变量指针的语法

```golang
ptr := &v // v 的类型为T
// 说明
// v: 代表被取地址的变量，类型为 T
// ptr: 用于接收地址的变量， ptr 的类型就是 *T 称做T的指针类型。 *代表指针
```

变量、指针地址、指针变量、取地址、取值的相互关系和特性如下

1. 对变量进行取地址（&）操作，可以获得这个变量的指针变量
2. 指针变量的值是指针地址
3. 对指针变量进行取值（*）操作，可以获得这个指针指向原变量的值

### 结构体

#### 结构体的定义

```golang
    type 类型名 struct {
        字段名 字段类型
        字段名 字段类型
        …
    }
// 说明:
// 1. 类型名： 标识自定义结构体的名称，同一个包内不能重复
// 2. 字段名： 表示结构体字段名，结构体中字段名必须唯一
// 3. 字段类型： 表示结构体字段的具体类型（可以是基础类型，也可以援引另外一个结构体）
```

#### 方法与接收者

Go语言中的方法（Method）是一种作用于特定类型变量的函数

```golang
// 定义
    func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) {
        函数体
    }
// 说明
// 1. 接收者变量：接收者中的参数变量名在命名时， \ 
//    官方建议使用接收者类型名的第一个小写字母，而不是self、this之类的命名。 \
//    例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。
// 2. 接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。
// 3. 方法名、参数列表、返回参数：具体格式与函数定义相同。
```

#### 结构体与JSON序列化

#### 结构体标签（TAG）

Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。  
结构体标签的定义

```golang
`key1:"value1" key2:"value2"`
```

> 注意： 为结构体编写Tag时，必须严格遵守键值对的规则

## 流程控制

### 条件语句if

if语句语法

```golang
- 可省略条件表达式括号
- 持初始化语句，可定义代码块局部变量
- 代码块左 括号必须在条件表达式尾部

// 句法
if 布尔表达式 {
    /* 在布尔表达式为true时执行 */
}
```

> *不支持三元操作符(三目运算符) "a > b ? a : b"

### 条件语句 switch

语法

```golang
switch var1 {   // va1 可以是任何类型
    case val1:
        ...
    case val2:
        ...
    default:
        ...
}
```

#### Type switch语法

```golang
switch x.(type){
    case type:
       statement(s)      
    case type:
       statement(s)
    /* 你可以定义任意个数的case */
    default: /* 可选 */
       statement(s)
}
```

### 条件语句 select

select 与 switch 类似，区别是 select 会随机执行一个可运行的 case。如果没有 case 可运行， select 将发生阻塞，直到有 case 可以执行为止。  
select 是 Go语言 中一个控制结构，类似用于通信的 swtich 语句。每个 case 必须是一个通信操作，要么是接收，要么是发送。 select 随机执行一个可运行的 case，如果没有可执行的 case, select 将发生阻塞，一个默认的子句（default:）应该总是可运行的。所以，如果除 default 之外所有 case 不可执行，那 select条件由 default 出条件。  
关于 select 语句的语法

> 1. 每个case都必须是一个通信
> 2. 所有channel表达式都会被求值
> 3. 所有被发送的表达式都会被求值
> 4. 如果任意某个通信可以进行，它就执行；其他被忽略。
> 5. 如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。（？如果有 default 这么看， default 的优先级应该是最低的，只是为了避免长时间堵塞而加入的一个默认值选项）  
>    5.1 否则1： 如果有default子句，则执行该语句。  
>    5.2 否则2： 如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值

### 循环语句 for

语法，主要有三种形式，只有一种使用分号（；）

```golang
for init; condition; post {}
for condition {}
for {}
// init: 一般为赋值表达式，给控制变量赋初始值
// conditon: 关系表达式或逻辑表达式，循环控制条件
// post: 一般为赋值表达式，给控制变量增量或者减量

for 语句执行过程：
1. 先对表达式 init 赋初始值
2. 判断复制表达式 init 是否满足给定的 condition 条件，如 True 执行循环体内语句，然后执行 post 。如 False，跳出循环，执行循环体外的语句。
```

### 循环语句 range

Golang range类似迭代器操作，返回 (索引, 值) 或 (键, 值)。  
for 循环的 range 格式可以对 slice, map, array, string等进行迭代循环  
语法格式

```golang
for key, value := range oldMap {
    newMap[key] = value
}
```

- |             | 1st value | 2nd value      | -             |
  | ----------- | --------- | -------------- | ------------- |
  | string      | index     | s[index]       | unicode, rune |
  | array/slice | index     | s[index]       | -             |
  | map         | key       | value(map[key] | -             |
  | channel     | element   | -              | -             |

  可忽略不想要的返回值，或 "_" 这个特殊变量。

#### 循环控制 goto, break, continue

> 1. 三个语句都可以配置标签（label）使用
> 2. 标签名区分大小写，确定以后如不适用会造成编译错误
> 3. continue, break 配合标签（label）可用于多层循环跳出
> 4. goto 是调整执行位置，与 continue, break 配合标签（label）的结果并不相同

## 函数

### 函数定义

特点

> - 无需声明原型
> - 支持不定变参
> - 支持多返回值
> - 支持命名返回参数
> - 支持匿名函数与闭包
> - 函数也是一种类型，可以函数可以赋值给变量。（注意，这点不太好理解，还需加强理解）  
> - 不支持： 嵌套（nested）一个包不能有两个名字一样的函数
> - 不支持： 重载（overload）
> - 不支持： 默认参数（default parameter）

函数声明的组成： func, 函数名， 参数列表， 返回值列表， 函数体, 返回语句。 如果函数没有返回值，则返回列表可以忽略。

```golang
func 函数名(形式参数列表)(返回值列表){
    函数体
}
```

Go语言有三种类型的函数：

1. 普通的带有名字的函数
2. 匿名函数或者 lambda 函数
3. 方法（这个有点绕，需要加深理解）

Go语言的函数调用格式

> 返回值变量列表 = 函数名（参数列表）
>
> - 说明：
>
> 1. 函数名： 需要调用的函数名
> 2. 参数列表：参数变量已逗号分割，尾部无需以分号结尾
> 3. 返回值变量列表：多个返回值使用逗号分隔
> 4. 有返回值的函数，必须有明确的终止语句，否则会引发编译错误

#### 函数参数

注意事项：

1. 默认情况下，Go语言使用的是值传递
2. 注意： 无论是值传递还是引用传递，传递给函数的都是变量的副本。
3. map, slice, channel, 指针， interface默认以引用方式传递
4. 不定参传值就是函数的参数不固定，后面的类型是固定的。（可变参数， Go语言可变参数本质上是slice， 只能有一个，而且必须是最后一个参数）

可变参数定义

```golang
  func myfunc(args ...int) {    //0个或多个参数
  }

  func add(a int, args…int) int {    //1个或多个参数
  }

  func add(a int, b int, args…int) int {    //2个或多个参数
  }

注意： args是一个slice，可以通过 range， slice[index]依次发给你问所有参数，也可以通过 len(args) 来判断传递参数的个数

  func myfunc(args ...interface{}) { // 传递任意类型的数据， interface{}是类型安全的
  }
```

#### 闭包与递归

##### 闭包

闭包是 由函数及其相关引用环境组合而成的实体（即： 闭包 = 函数 + 引用环境） 。官方结实，闭包，指 一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 感觉有点拗口，还需加深理解。  

##### 递归

递归指在运行过程中调用自己。典型使用场景，阶乘计算，斐波那契数列计算。

> 构成递归具备的条件
>
> 1. 子问题必须与原始问题做同样的事，且更为简单
> 2. 不能无限制地调用本身，必须有一个出口（在满足一定条件），化简为非递归状况跳出递归

#### 延迟调用 defer， 其实理解的不是很透彻，还需再看一遍

特性

> 1. 关键词 defer 用于注册延迟调用
> 2. 这些调用直到 return 前才被执行，由此，可做资源清理。如(os.Close(*File))
> 3. 多个 defer 语句，按照先进后出的方式执行。栈处理
> 4. defer 语句中的变量，在 defer 声明时就决定了
>    用途
> 5. 关闭文件句柄
> 6. 锁资源释放
> 7. 连接释放（数据库， TCP， http等连接）

注意： 我个人认为 defer 的实现核心为，栈内存以及阻塞，所以需要注意延迟的阻塞


